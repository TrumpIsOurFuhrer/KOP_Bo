// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Drivetrain.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/Driving.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

Drivetrain::Drivetrain() : Subsystem("Drivetrain") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	aMotor = RobotMap::drivetrainCANTalon1;
	bMotor = RobotMap::drivetrainCANTalon2;
	cMotor = RobotMap::drivetrainCANTalon3;
	dMotor = RobotMap::drivetrainCANTalon4;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Drivetrain::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new Driving());
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

 /* Drive Robot with Joystick. Originallly only forward, now has implementation of smooth motion (limiting acceleration).
  *
  * */

void Drivetrain::DriveForwardJoystick(Joystick* joy){

		/*Attempt at smooth motion below
		 * Number 1 problem: abs is only returning int values
		 * so the if statement always outputs false.
		 * Solution: fabs, it is the float equivalent for abs.
		*/

	/* Explaining absign and cdsign
	 * The sign of the acceleration. Not yet accurate, still using incorrect methods.
	 * Methodology: Check the acceleration of the motors a and b (should always be identical) and the same for c and d
	 * If the acceleration is equal to 0, set the absign value to 0.5 to ensure no dividing by 0.
	 * Otherwise, match the sign of the acceleration.
	 */
	float absign, cdsign;

	if((joy->GetY()+.25*joy->GetZ()-aMotor->Get())==0){
		absign = 0.5;
	}
	else {absign = fabs(joy->GetY()+.25*joy->GetZ()-aMotor->Get())/(joy->GetY()+.25*joy->GetZ()-aMotor->Get());}

	if((-1*joy->GetY()+.25*joy->GetZ()-cMotor->Get())==0){
		cdsign = 0.5;
	}
	else {cdsign = fabs(-1*joy->GetY()+.25*joy->GetZ()-cMotor->Get())/(-1*joy->GetY()+.25*joy->GetZ()-cMotor->Get());}

	/*Checks if acceleration or deceleration is more than limit. If it is, then it will go up or down by the limit
	 *For fine tuning of smooth motion, adjust accelLim. Do realize, 20ms cycle so the number should be small to have an effect. How small is the fine-tuning.
	 *TODO: Turn the Z axis multiplier to a variable and add one for the Y axis. Benefit, fine-tuning is much faster.
	 * Second benefit is able to have a button on the smartdashboard to slow down the robot a lot. Good for when letting people drive the robot at events. Could use accelLim as well.
	 *TODO: Try different styles of controlling driving. Ex. Xbox control use lt and rt for forward and reverse and stick still for turning (like gaming)
	 */
	float accelLim = .01;

	if(
			fabs(fabs(joy->GetY()+.25*joy->GetZ())-fabs(aMotor->Get())) > accelLim){
		//Acceleration is more than limit (or deceleration)
		aMotor->Set(aMotor->Get()+absign*accelLim);}
	else {
		//Acceleration is less than limit
		aMotor->Set(joy->GetY()+.25*joy->GetZ());}
	if(fabs(fabs(joy->GetY()+.25*joy->GetZ())-fabs(100*bMotor->Get())) > accelLim){
		bMotor->Set(bMotor->Get()+absign*accelLim);}
	else {
		bMotor->Set(joy->GetY()+.25*joy->GetZ());}
	if(fabs(fabs(-1*joy->GetY()+.25*joy->GetZ())-fabs(cMotor->Get())) > accelLim){
		cMotor->Set(cMotor->Get()+cdsign*accelLim);}
	else {
		cMotor->Set(-1*joy->GetY()+.25*joy->GetZ());}
	if(fabs(fabs(-1*joy->GetY()+.25*joy->GetZ())-fabs(dMotor->Get())) > accelLim){
		dMotor->Set(dMotor->Get()+cdsign*accelLim);}
	else {
		dMotor->Set(-1*joy->GetY()+.25*joy->GetZ());}

	}

// Put methods for controlling this subsystem
// here. Call these from Commands.

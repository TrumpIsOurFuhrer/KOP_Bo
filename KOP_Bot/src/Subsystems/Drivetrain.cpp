<<<<<<< HEAD
// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Drivetrain.h"
#include "../RobotMap.h"
#include "cmath"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/Driving.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

Drivetrain::Drivetrain() : Subsystem("Drivetrain") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	aMotor = RobotMap::drivetrainCANTalon1;
	bMotor = RobotMap::drivetrainCANTalon2;
	cMotor = RobotMap::drivetrainCANTalon3;
	dMotor = RobotMap::drivetrainCANTalon4;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Drivetrain::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new Driving());
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Drivetrain::DriveForwardJoystick(Joystick* joy){

		/*Attempt at smooth motion below
		 * Number 1 problem: abs is only returning int values
		 * so the if statement always outputs false.
		*/
	float absign, cdsign;

	if(aMotor->Get()==0){
		absign = 0.5;
	}
	else {absign = abs(aMotor->Get())/aMotor->Get();}

	if(cMotor->Get()==0){
		cdsign = 0.5;
	}
	else {cdsign = abs(cMotor->Get())/cMotor->Get();}

	if(std::abs(abs(joy->GetY()+.25*joy->GetZ())-abs(aMotor->Get())) > .00001){
		aMotor->Set(aMotor->Get()+absign*.00001);}
	else {
		aMotor->Set(joy->GetY()+.25*joy->GetZ());}
	if(abs(abs(joy->GetY()+.25*joy->GetZ())-abs(bMotor->Get())) > .00001){
		bMotor->Set(bMotor->Get()+absign*.00001);}
	else {
		bMotor->Set(joy->GetY()+.25*joy->GetZ());}
	if(abs(abs(joy->GetY()+.25*joy->GetZ())-abs(cMotor->Get())) > .00001){
		cMotor->Set(cMotor->Get()+cdsign*.00001);}
	else {
		cMotor->Set(-1*joy->GetY()+.25*joy->GetZ());}
	if(abs(abs(joy->GetY()+.25*joy->GetZ())-abs(dMotor->Get())) > .00001){
		dMotor->Set(dMotor->Get()+cdsign*.00001);}
	else {
		dMotor->Set(-1*joy->GetY()+.25*joy->GetZ());}

	}

// Put methods for controlling this subsystem
// here. Call these from Commands.

=======
// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Drivetrain.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/Driving.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

Drivetrain::Drivetrain() : Subsystem("Drivetrain") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	aMotor = RobotMap::drivetrainCANTalon1;
	bMotor = RobotMap::drivetrainCANTalon2;
	cMotor = RobotMap::drivetrainCANTalon3;
	dMotor = RobotMap::drivetrainCANTalon4;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Drivetrain::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new Driving());
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

 /* Drive Robot with Joystick. Originallly only forward, now has implementation of smooth motion (limiting acceleration).
  *
  * */

void Drivetrain::DriveForwardJoystick(Joystick* joy){

		/*Attempt at smooth motion below
		 * Number 1 problem: abs is only returning int values
		 * so the if statement always outputs false.
		*/

	/* Explaining absign and cdsign
	 * The sign of the acceleration. Not yet accurate, still using incorrect methods.
	 */
	float absign, cdsign;

	if((joy->GetY()+.25*joy->GetZ())==0){
		absign = 0.5;
	}
	else {absign = abs(joy->GetY()+.25*joy->GetZ())/(joy->GetY()+.25*joy->GetZ());}

	if((-1*joy->GetY()+.25*joy->GetZ())==0){
		cdsign = 0.5;
	}
	else {cdsign = abs(-1*joy->GetY()+.25*joy->GetZ())/(-1*joy->GetY()+.25*joy->GetZ());}

	//if statements check if acceleration or deceleration is more than limit. Refer to problem #1 above. Can be fixed my using all integers for if statement
	//Which is done by multiplying all values in the if statement by a suitably large number. Want to have it limited to .01 per cycle? Multiply all values by 100 and the threshold is now 1.

	if(		//abs is rounding up the numbers to 1 so the answer is always 0 (1-1) meaning it is never greater than the limit
			std::abs(abs(joy->GetY()+.25*joy->GetZ())-abs(aMotor->Get())) > .00001){
		//Acceleration is more than limit. Currently inactive until problem number 1 is fixed so it can be activated
		aMotor->Set(aMotor->Get()+absign*.00001);}
	else {
		//Acceleration is less than limit
		aMotor->Set(joy->GetY()+.25*joy->GetZ());}
	if(abs(abs(joy->GetY()+.25*joy->GetZ())-abs(bMotor->Get())) > .00001){
		bMotor->Set(bMotor->Get()+absign*.00001);}
	else {
		bMotor->Set(joy->GetY()+.25*joy->GetZ());}
	if(abs(abs(joy->GetY()+.25*joy->GetZ())-abs(cMotor->Get())) > .00001){
		cMotor->Set(cMotor->Get()+cdsign*.00001);}
	else {
		cMotor->Set(-1*joy->GetY()+.25*joy->GetZ());}
	if(abs(abs(joy->GetY()+.25*joy->GetZ())-abs(dMotor->Get())) > .00001){
		dMotor->Set(dMotor->Get()+cdsign*.00001);}
	else {
		dMotor->Set(-1*joy->GetY()+.25*joy->GetZ());}

	}

// Put methods for controlling this subsystem
// here. Call these from Commands.

>>>>>>> origin/PenchentBranch
